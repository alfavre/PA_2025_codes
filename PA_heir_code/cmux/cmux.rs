
use std::collections::BTreeMap;
use tfhe::boolean::prelude::*;

pub fn cmux(
  v0: &ServerKey,
  v1: &Vec<Ciphertext>,
  v2: &Vec<Ciphertext>,
  v3: &Ciphertext,
) -> Vec<Ciphertext> {
  let v4 = 7;
  let v5 = 6;
  let v6 = 5;
  let v7 = 4;
  let v8 = 3;
  let v9 = 2;
  let v10 = 1;
  let v11 = 0;
  let v12 = 15;
  let v13 = 14;
  let v14 = 13;
  let v15 = 12;
  let v16 = 11;
  let v17 = 10;
  let v18 = 9;
  let v19 = 8;
  let v20 = v0.not(v3);
  let v21 = &v1[v19];
  let v22 = v0.nand(v21, v3);
  let v23 = &v2[v19];
  let v24 = v0.nand(v23, &v20);
  let v25 = v0.nand(&v22, &v24);
  let v26 = &v1[v18];
  let v27 = v0.nand(v3, v26);
  let v28 = &v2[v18];
  let v29 = v0.nand(&v20, v28);
  let v30 = v0.nand(&v27, &v29);
  let v31 = &v1[v17];
  let v32 = v0.nand(v3, v31);
  let v33 = &v2[v17];
  let v34 = v0.nand(&v20, v33);
  let v35 = v0.nand(&v32, &v34);
  let v36 = &v1[v16];
  let v37 = v0.nand(v3, v36);
  let v38 = &v2[v16];
  let v39 = v0.nand(&v20, v38);
  let v40 = v0.nand(&v37, &v39);
  let v41 = &v1[v15];
  let v42 = v0.nand(v3, v41);
  let v43 = &v2[v15];
  let v44 = v0.nand(&v20, v43);
  let v45 = v0.nand(&v42, &v44);
  let v46 = &v1[v14];
  let v47 = v0.nand(v3, v46);
  let v48 = &v2[v14];
  let v49 = v0.nand(&v20, v48);
  let v50 = v0.nand(&v47, &v49);
  let v51 = &v1[v13];
  let v52 = v0.nand(v3, v51);
  let v53 = &v2[v13];
  let v54 = v0.nand(&v20, v53);
  let v55 = v0.nand(&v52, &v54);
  let v56 = &v1[v12];
  let v57 = v0.nand(v3, v56);
  let v58 = &v2[v12];
  let v59 = v0.nand(&v20, v58);
  let v60 = v0.nand(&v57, &v59);
  let v61 = &v1[v11];
  let v62 = v0.nand(v3, v61);
  let v63 = &v2[v11];
  let v64 = v0.nand(&v20, v63);
  let v65 = v0.nand(&v62, &v64);
  let v66 = &v1[v10];
  let v67 = v0.nand(v3, v66);
  let v68 = &v2[v10];
  let v69 = v0.nand(&v20, v68);
  let v70 = v0.nand(&v67, &v69);
  let v71 = &v1[v9];
  let v72 = v0.nand(v3, v71);
  let v73 = &v2[v9];
  let v74 = v0.nand(&v20, v73);
  let v75 = v0.nand(&v72, &v74);
  let v76 = &v1[v8];
  let v77 = v0.nand(v3, v76);
  let v78 = &v2[v8];
  let v79 = v0.nand(&v20, v78);
  let v80 = v0.nand(&v77, &v79);
  let v81 = &v1[v7];
  let v82 = v0.nand(v3, v81);
  let v83 = &v2[v7];
  let v84 = v0.nand(&v20, v83);
  let v85 = v0.nand(&v82, &v84);
  let v86 = &v1[v6];
  let v87 = v0.nand(v3, v86);
  let v88 = &v2[v6];
  let v89 = v0.nand(&v20, v88);
  let v90 = v0.nand(&v87, &v89);
  let v91 = &v1[v5];
  let v92 = v0.nand(v3, v91);
  let v93 = &v2[v5];
  let v94 = v0.nand(&v20, v93);
  let v95 = v0.nand(&v92, &v94);
  let v96 = &v1[v4];
  let v97 = v0.nand(v3, v96);
  let v98 = &v2[v4];
  let v99 = v0.nand(&v20, v98);
  let v100 = v0.nand(&v97, &v99);
  let mut v101 : BTreeMap<(usize), Ciphertext> = BTreeMap::new();
  v101.insert((v11 as usize), v65.clone());
  v101.insert((v10 as usize), v70.clone());
  v101.insert((v9 as usize), v75.clone());
  v101.insert((v8 as usize), v80.clone());
  v101.insert((v7 as usize), v85.clone());
  v101.insert((v6 as usize), v90.clone());
  v101.insert((v5 as usize), v95.clone());
  v101.insert((v4 as usize), v100.clone());
  v101.insert((v19 as usize), v25.clone());
  v101.insert((v18 as usize), v30.clone());
  v101.insert((v17 as usize), v35.clone());
  v101.insert((v16 as usize), v40.clone());
  v101.insert((v15 as usize), v45.clone());
  v101.insert((v14 as usize), v50.clone());
  v101.insert((v13 as usize), v55.clone());
  v101.insert((v12 as usize), v60.clone());
  v101.into_values().collect()
}
